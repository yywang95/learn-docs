# 防抖(debounce)和节流(throttle)

> 为什么存在?
> 为了避免持续触发事件(mouse、resize、scroll等)频繁的发生

## 防抖(debounce)

> 定义：触发事件后在n秒内函数只能执行一次，如果在n秒内又触发了事件，则会重新计算函数执行时间

防抖分为`非立即执行`和`立即执行`

#### 非立即执行

在最后一次调用事件`n秒后执行`函数

```javascript
function debounce(func, wait) {
    let timeout;

    return function () {
        const context = this;
        const args = arguments;

        if (timeout) clearTimeout(timeout);

        timeout = setTimeout(() => {
            func.apply(context, args);
        });
    };
}
```

#### 立即执行

执行一次函数后，在`其后`最后一次调用事件`n秒内`触发的函数都`不执行`

```javascript
function debounce(func, wait) {
    let timeout;

    return function () {
        const context = this;
        const args = arguments;

        if (timeout) clearTimeout(timeout);
        
        const callNow = !timeout;

        timeout = setTimeout(() => {
            timeout = null;
        }, wait);

        if (callNow) func.apply(context, args);
    };
}
```
----

## 节流

> 定义：固定的n秒时间段内只执行一次函数，节流会稀释函数的执行频率

防抖分为`时间戳版`和`定时器版`

#### 时间戳版

计算本次执行和上次执行的时间差，如果大于执行时间则执行，对于连续触发的事件，时间戳函数触发是在时间段内开始的时候

```javascript
function throttle(func, wait) {
    let previous = 0;

    return function () {
        const now = Date.now();
        const context = this;
        const args = arguments;

        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```

#### 定时器版

停止触发后事件还会被触发一次，对于连续触发的事件，定时器版是在时间段内结束的时候

```javascript
function throttle(func, wait) {
    let timeout;

    return function () {
        const context = this;
        const args = arguments;

        if (!timeout) {
            timeout = setTimeout(() => {
                timeout = null;
                func.apply(context, args);
            }, wait);
        }
    };
}
```

## 完整代码

#### 防抖

```javascript
/**
 * @desc 函数防抖
 * @param {Function} func 被执行函数
 * @param {Number} wait 延迟执行毫秒数
 * @param {Boolean} immediate 是否立即执行
 */
function debounce(func, wait, immediate) {
    let timeout;

    return funciton () {
        const context = this;
        const args = arguments;

        if (timeout) clearTimeout(timeout);

        if (immediate) {
            const callNow = !timeout;

            timeout = setTimeout(() => {
                timeout = null;
            }, wait);

            if (callNow) func.apply(context, args);
        } else {
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        }
    };
}
```

#### 节流

```javascript
/**
 * 节流函数
 * @param {Function} callback 需要节流的方法
 * @param {Number} delay 多少时间间隔执行一次
 * @param {Boolean} noTrailing 停止后是否取消执行
 * @return {Function} 封装后的方法
 * @example throttle(() => {}, 1000)
 */
function throttle(callback, delay, noTrailing) {
    let timeoutID; // 最后一次计时器
    let cancelled = false; // 是否取消定时事件
    let lastExec = 0; // 上次执行方法时间

    const clearExistingTimeout = () => {
        if (timeoutID) clearTimeout(timeoutID); // 清除计时
    };

    const cancel = () => {
        cancelled = true; // 取消事件
    };

    const wrapper = (...params) => {
        if (cancelled) return; // 如果取消定时时间，则返回

        const self = this;
        const args = params;
        const elapsed = Date.now() - lastExec; // 当前执行方法时间 - 上次执行方法时间

        const exec = () => {
            lastExec = Date.now(); // 更新执行时间
            callback.apply(self, args); // 执行回调
        };

        clearExistingTimeout(); // 清除上一次计时

        if (elapsed > delay) {
            exec(); // 到另一个时间间隔时执行方法
        } else if (noTrailing !== true) {
            timeoutID = setTimeout(exec, delay - elapsed); // 停止后执行最后一次
        }
    };

    wrapper.cancel = cancel;

    return wrapper;
}
```